# OwlProgram
Dynamically loaded OWL program.
See http://hoxtonowl.com for more details of the Open Ware Laboratory.

# Instructions

## Prerequisites
* gcc arm compiler (to make patch binary) [1]
* FirmwareSender (to make sysex and run) [2]
* emcc (to make web) [3]

## Make targets
* make patch: build patch binary
* make sysex: package binary as sysex
* make run: upload patch to attached OWL
* make store: upload and save to attached OWL
* make web: build Javascript patch

## Make options
* PATCHNAME: specify name of patch, e.g. SimpleDelay
* PATCHCLASS: name of patch class, e.g. SimpleDelayPatch
* PATCHFILE: name of main patch file, e.g. SimpleDelayPatch.hpp
* PATCHIN: number of input channels, default 2
* PATCHOUT: number of output channels, default 2
* SLOT: user program slot to store patch in, default 0

If you follow the convention of SimpleDelay then you don't have to specify `PATCHCLASS` and `PATCHFILE`, they will be deduced from `PATCHNAME`.

Copy all patch files to `PatchSource` folder.

Example: Compile and run the TestTone patch, defined in file `PatchSource/TestTonePatch.hpp` as class `TestTonePatch`:
`make PATCHNAME=TestTone run`

Example: Compile and run in browser
`make PATCHNAME=TestTone web`
Then open `WebSource/patch.html`

To compile a PD patch into OWL sysex, with C code generated by Enzien Audio:
* make a Heavy project called `Heavy` and compile your PD patch to C
* unzip Heavy C code into `PatchSource`
* `make PATCHNAME=Heavy sysex`

To compile a FAUST patch into OWL sysex (note: specify .hpp file as additional target)
* copy .dsp file into `PatchSource`, e.g. `LowShelf.dsp`
* `make PATCHNAME=LowShelf Build/LowShelfPatch.hpp sysex`

[1] https://launchpad.net/gcc-arm-embedded
[2] https://github.com/pingdynasty/FirmwareSender
[3] http://emscripten.org
